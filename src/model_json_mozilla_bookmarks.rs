//extern crate serde_derive;
// data model (schema) for json serde
pub mod model_json_mozilla_bookmarks {
    use crate::model_manga::{self, model_manga::MangaModel};
    use serde::{Deserialize, Serialize};
    use std::fmt::{Debug, Display};

    /// Generated by https://quicktype.io

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct BookmarkRootFolder {
        #[serde(rename = "guid")]
        guid: String,

        #[serde(rename = "title")]
        title: String,

        #[serde(rename = "index")]
        index: i64,

        #[serde(rename = "dateAdded")]
        date_added: i64,

        #[serde(rename = "lastModified")]
        last_modified: i64,

        #[serde(rename = "id")]
        id: i64,

        #[serde(rename = "typeCode")]
        type_code: i64,

        #[serde(rename = "type")]
        bookmark_type: Type, // almost most likely it will always be "text/x-moz-place-container" here

        #[serde(rename = "root")]
        root: String,

        #[serde(rename = "children")]
        children: Vec<BookmarkNodes>, // this is the root folder container, so we may have children here
    }

    impl Display for BookmarkRootFolder {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "BookmarkRootFolder {{\n")?;
            write!(f, "  title: {}\n", self.title)?;
            write!(f, "  index: {}\n", self.index)?;
            write!(f, "  date_added: {}\n", self.date_added)?;
            write!(f, "  last_modified: {}\n", self.last_modified)?;
            write!(f, "  id: {}\n", self.id)?;
            write!(f, "  type_code: {}\n", self.type_code)?;
            write!(f, "  bookmark_type: {}\n", self.bookmark_type)?;
            write!(f, "  root: {}\n", self.root)?;
            write!(f, "  children: [\n")?;
            for child in &self.children {
                write!(f, "    {},\n", child)?;
            }
            write!(f, "  ]\n")?;
            write!(f, "}}")
        }
    }

    impl BookmarkRootFolder {
        pub fn new(
            guid: String,
            title: String,
            index: i64,
            date_added: i64,
            last_modified: i64,
            id: i64,
            type_code: i64,
            bookmark_type: Type,
            root: String,
            children: Vec<BookmarkNodes>,
        ) -> BookmarkRootFolder {
            BookmarkRootFolder {
                guid,
                title,
                index,
                date_added,
                last_modified,
                id,
                type_code,
                bookmark_type,
                root,
                children,
            }
        }
        pub fn children(&self) -> &Vec<BookmarkNodes> {
            &self.children
        }
    }

    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct BookmarkNodes {
        #[serde(rename = "guid")]
        guid: String,

        #[serde(rename = "title")]
        title: String,

        #[serde(rename = "index")]
        index: i64,

        #[serde(rename = "dateAdded")]
        date_added: i64,

        #[serde(rename = "lastModified")]
        last_modified: i64,

        #[serde(rename = "id")]
        id: i64,

        #[serde(rename = "typeCode")]
        type_code: i64,

        #[serde(rename = "type")]
        child_type: Type, // we only care about "text/x-moz-place"

        #[serde(rename = "root")]
        possible_root: Option<String>,

        #[serde(rename = "children")]
        possible_children: Option<Vec<BookmarkNodes>>, // if this was "text/x-moz-place-container", we'd have children here...

        #[serde(rename = "uri")]
        possible_uri: Option<String>,
    }

    impl Display for BookmarkNodes {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "BookmarkRootFolder {{\n")?;
            write!(f, "  title: {}\n", self.title)?;
            write!(f, "  index: {}\n", self.index)?;
            write!(f, "  date_added: {}\n", self.date_added)?;
            write!(f, "  last_modified: {}\n", self.last_modified)?;
            write!(f, "  id: {}\n", self.id)?;
            write!(f, "  type_code: {}\n", self.type_code)?;
            write!(f, "  child_type: {}\n", self.child_type)?;
            write!(f, "  root: {:?}\n", self.possible_root)?;
            write!(f, "  children:\n")?;
            match &self.possible_children {
                Some(children) => {
                    write!(f, "  children: [\n")?;
                    for child in children {
                        write!(f, "    {},\n", child)?;
                    }
                    write!(f, "  ]\n")?
                }
                None => write!(f, "    None,\n")?,
            };
            write!(f, "  uri: {:?}\n", self.possible_uri)?;
            write!(f, "}}")
        }
    }

    impl BookmarkNodes {
        pub fn new(
            guid: String,
            title: String,
            index: i64,
            date_added: i64,
            last_modified: i64,
            id: i64,
            type_code: i64,
            child_type: Type,
            possible_root: Option<String>,
            possible_children: Option<Vec<BookmarkNodes>>,
            possible_uri: Option<String>,
        ) -> BookmarkNodes {
            BookmarkNodes {
                guid,
                title,
                index,
                date_added,
                last_modified,
                id,
                type_code,
                child_type,
                possible_root,
                possible_children,
                possible_uri,
            }
        }
        pub fn is_bookmark(&self) -> bool {
            self.child_type == Type::TextXMozPlace
        }

        pub fn title(&self) -> &String {
            &self.title
        }

        pub fn uri(&self) -> String {
            // return asn empty string if it is not a bookmark and/or is None
            if self.child_type != Type::TextXMozPlace {
                return String::from("");
            }
            match &self.possible_uri {
                Some(uri) => uri.clone(),
                None => String::from(""),
            }
        }

        pub fn last_modified(&self) -> &i64 {
            &self.last_modified
        }

        pub fn possible_children(&self) -> &Option<Vec<BookmarkNodes>> {
            &self.possible_children
        }

        // from model_manga
        pub fn to_model_manga(&self) -> Option<MangaModel> {
            // only way it can fail  is if uri is poorly formatted (sometimes, it's surrounded with double quotes)
            // or if title is empty
            if !self.is_bookmark() {
                return None;
            }
            if self.title.is_empty() {
                return None;
            }
            if self.uri().is_empty() {
                return None;
            }

            let title = self.title.clone();
            match MangaModel::new_from_required_elements(
                title.clone().as_str(),
                self.uri().as_str(),
                model_manga::CASTAGNOLI.checksum(title.clone().as_bytes()),
            ) {
                Ok(manga) => Some(manga),
                Err(e) => {
                    println!("Error: {}", e);
                    None
                }
            }
        }

        // to model_manga
    }

    #[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
    pub enum Type {
        #[serde(rename = "text/x-moz-place")]
        TextXMozPlace,

        #[serde(rename = "text/x-moz-place-container")]
        TextXMozPlaceContainer,

        #[serde(rename = "text/x-moz-place-separator")]
        TextXMozPlaceSeparator,
    }

    impl Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Type::TextXMozPlace => write!(f, "text/x-moz-place"),
                Type::TextXMozPlaceContainer => write!(f, "text/x-moz-place-container"),
                Type::TextXMozPlaceSeparator => write!(f, "text/x-moz-place-separator"),
            }
        }
    }

    #[cfg(test)]
    mod tests {
        use std::{fs::File, io::BufReader};

        use super::*;
        use serde_json::json;
        #[test]
        fn test_serialize_firefox_bookmark() {
            let json_data = r#"
{ "guid": "root________", "title": "", "index": 0, "dateAdded": 1687548918712000, "lastModified": 1689519935422000, "id": 1, "typeCode": 2, "type": "text/x-moz-place-container", "root": "placesRoot", "children": [ { "guid": "menu________", "title": "menu", "index": 0, "dateAdded": 1687548918712000, "lastModified": 1688395173395000, "id": 2, "typeCode": 2, "type": "text/x-moz-place-container", "root": "bookmarksMenuFolder", "children": [ { "guid": "A8NUOjpsRO1f", "title": "", "index": 0, "dateAdded": 1687548920094000, "lastModified": 1687548920094000, "id": 15, "typeCode": 3, "type": "text/x-moz-place-separator" } ] }, { "guid": "toolbar_____", "title": "toolbar", "index": 1, "dateAdded": 1687548918712000, "lastModified": 1689519935422000, "id": 3, "typeCode": 2, "type": "text/x-moz-place-container", "root": "toolbarFolder", "children": [ { "guid": "Npno2qvkXy1F", "title": "Downloads", "index": 0, "dateAdded": 1688676588125000, "lastModified": 1688676595137000, "id": 19, "typeCode": 1, "type": "text/x-moz-place", "uri": "about:downloads" }, { "guid": "EvEy7VW_sMTG", "title": "ゆるキャン△", "index": 1, "dateAdded": 1689519634292000, "lastModified": 1689519634292000, "id": 20, "typeCode": 1, "type": "text/x-moz-place", "uri": "https://some-site/page-of-this-manga" } ] }, { "guid": "unfiled_____", "title": "unfiled", "index": 3, "dateAdded": 1687548918712000, "lastModified": 1687548919979000, "id": 5, "typeCode": 2, "type": "text/x-moz-place-container", "root": "unfiledBookmarksFolder" }, { "guid": "mobile______", "title": "mobile", "index": 4, "dateAdded": 1687548918955000, "lastModified": 1687548919979000, "id": 6, "typeCode": 2, "type": "text/x-moz-place-container", "root": "mobileFolder" } ] }
        "#;
            // deserialize
            let bookmark: BookmarkRootFolder = serde_json::from_str(json_data).unwrap();
            // for test, just recursively traverse down each children and print the title and lastModified and the type
            fn traverse_children(children: &Vec<BookmarkNodes>) {
                for child in children {
                    println!(
                        "title: {}, type: {:#?}, lastModified: {}, uri: {:#?}",
                        child.title, child.child_type, child.last_modified, child.possible_uri
                    );
                    if let Some(children) = &child.possible_children {
                        traverse_children(children);
                    }
                }
            }
            traverse_children(&bookmark.children);
        }

        #[test]
        fn test_deserialize_bookmark_with_two_nodes() {
            //let json_data = json!(
            //{
            //    "guid": "root________",
            //    "title": "",
            //    "index": 0,
            //    "dateAdded": 1687548918712000 as i64,
            //    "lastModified": 1689519935422000 as i64,
            //    "id": 1,
            //    "typeCode": 2,
            //    "type": "text/x-moz-place-container",
            //    "root": "placesRoot",
            //    "children": [
            //        {
            //            "guid": "menu________",
            //            "title": "menu",
            //            "index": 0,
            //            "dateAdded": 1687548918712000 as i64,
            //            "lastModified": 1688395173395000 as i64,
            //            "id": 2,
            //            "typeCode": 2,
            //            "type": "text/x-moz-place-container",
            //            "root": "bookmarksMenuFolder",
            //            "children": [
            //                {
            //                    "guid": "A8NUOjpsRO1f",
            //                    "title": "",
            //                    "index": 0,
            //                    "dateAdded": 1687548920094000 as i64,
            //                    "lastModified": 1687548920094000 as i64,
            //                    "id": 15,
            //                    "typeCode": 3,
            //                    "type": "text/x-moz-place-separator"
            //                }
            //            ]
            //        },
            //        {
            //            "guid": "toolbar_____",
            //            "title": "toolbar",
            //            "index": 1,
            //            "dateAdded": 1687548918712000 as i64,
            //            "lastModified": 1689519935422000 as i64,
            //            "id": 3,
            //            "typeCode": 2,
            //            "type": "text/x-moz-place-container",
            //            "root": "toolbarFolder",
            //            "children": [
            //                {
            //                    "guid": "Npno2qvkXy1F",
            //                    "title": "Downloads",
            //                    "index": 0,
            //                    "dateAdded": 1688676588125000 as i64,
            //                    "lastModified": 1688676595137000 as i64,
            //                    "id": 19,
            //                    "typeCode": 1,
            //                    "type": "text/x-moz-place",
            //                    "uri": "about:downloads"
            //                },
            //                {
            //                    "guid": "EvEy7VW_sMTG",
            //                    "title": "ゆるキャン△",
            //                    "index": 1,
            //                    "dateAdded": 1689519634292000 as i64,
            //                    "lastModified": 1689519634292000 as i64,
            //                    "id": 20,
            //                    "typeCode": 1,
            //                    "type": "text/x-moz-place",
            //                    "uri": "https://some-site/page-of-this-manga"
            //                }
            //            ]
            //        },
            //        {
            //            "guid": "unfiled_____",
            //            "title": "unfiled",
            //            "index": 3,
            //            "dateAdded": 1687548918712000 as i64,
            //            "lastModified": 1687548919979000 as i64,
            //            "id": 5,
            //            "typeCode": 2,
            //            "type": "text/x-moz-place-container",
            //            "root": "unfiledBookmarksFolder"
            //        },
            //        {
            //            "guid": "mobile______",
            //            "title": "mobile",
            //            "index": 4,
            //            "dateAdded": 1687548918955000 as i64,
            //            "lastModified": 1687548919979000 as i64,
            //            "id": 6,
            //            "typeCode": 2,
            //            "type": "text/x-moz-place-container",
            //            "root": "mobileFolder"
            //        }
            //    ]
            //});
            //let bookmark: BookmarkRootFolder = serde_json::from_value(json_data).unwrap();
            // Because the new JSON is huge, it causes macro recursion overflow for json!(), so we'll
            // read from file instead...
            let file = File::open("tests/input.prettified.json").unwrap();
            let rader = BufReader::new(file);
            let bookmark_from_file: BookmarkRootFolder = serde_json::from_reader(rader).unwrap();

            for node in &bookmark_from_file.children {
                println!(
                    "\nNode title: '{}', type: {:#?}, lastModified: {:#?}, uri: {:#?}, child-count: {}",
                    node.title, node.child_type, node.last_modified, node.possible_uri, match &node.possible_children {
                        Some(children) => children.len(),
                        None => 0,
                    }
                );

                if let Some(node_children) = &node.possible_children {
                    for child in node_children {
                        println!(
                            ">\tChild title: '{}', Child type: {:#?}, lastModified: {:#?}, uri: {:#?}, child-count: {}",
                            child.title,
                            child.child_type,
                            child.last_modified,
                            child.possible_uri,
                            match &child.possible_children {
                                Some(children) => children.len(),
                                None => 0,
                            }
                        );
                        if child.is_bookmark() {
                            println!(">>\t\tis bookmark");
                        }
                        for grandchildren in child.possible_children() {
                            println!(">>>\t\tGrandchildren count: {}", grandchildren.len());
                            for greatgrandchildren in grandchildren {
                                println!(
                                    ">>>\t\t\tGrandchild title: '{}', Child type: {:#?}, lastModified: {:#?}, uri: {:#?}, child-count: {}",
                                    greatgrandchildren.title,
                                    greatgrandchildren.child_type,
                                    greatgrandchildren.last_modified,
                                    greatgrandchildren.possible_uri,
                                    match &greatgrandchildren.possible_children {
                                        Some(children) => children.len(),
                                        None => 0,
                                    }
                                );
                            }
                        }
                    }
                }
                println!("");
            }
        }
    }
}
